<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: kikimr/public/api/protos/ydb_persqueue_v1.proto

namespace Ydb\PersQueue\V1\ReadInfoResult\TopicInfo;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * Message containing information about concrete topic's partition reading.
 *
 * Generated from protobuf message <code>Ydb.PersQueue.V1.ReadInfoResult.TopicInfo.PartitionInfo</code>
 */
class PartitionInfo extends \Google\Protobuf\Internal\Message
{
    /**
     * Patition identifier inside topic.
     *
     * Generated from protobuf field <code>uint64 partition = 1;</code>
     */
    protected $partition = 0;
    /**
     * Request status of partition.
     *
     * Generated from protobuf field <code>.Ydb.StatusIds.StatusCode status = 2;</code>
     */
    protected $status = 0;
    /**
     * Issues if any.
     *
     * Generated from protobuf field <code>repeated .Ydb.Issue.IssueMessage issues = 3;</code>
     */
    private $issues;
    /**
     * Offset of first message in partition.
     *
     * Generated from protobuf field <code>uint64 start_offset = 4;</code>
     */
    protected $start_offset = 0;
    /**
     * Offset of next not yet existing message in partition.
     *
     * Generated from protobuf field <code>uint64 end_offset = 5;</code>
     */
    protected $end_offset = 0;
    /**
     * Offset of consumer committed message a.k.a. first not processed message.
     * If commit_offset == end_offset then all messages from partition are processed.
     *
     * Generated from protobuf field <code>uint64 commit_offset = 6;</code>
     */
    protected $commit_offset = 0;
    /**
     * Consumer lag in time between committed and last messages in partition.
     *
     * Generated from protobuf field <code>uint64 commit_time_lag_ms = 7;</code>
     */
    protected $commit_time_lag_ms = 0;
    /**
     * Offset of first not read message by consumer from this partition.
     * read_offset can be bigger that committed_offset - consumer could read some messages but not yet commit them.
     *
     * Generated from protobuf field <code>uint64 read_offset = 8;</code>
     */
    protected $read_offset = 0;
    /**
     * Consumer lag in time between read and last messages in partition.
     *
     * Generated from protobuf field <code>uint64 read_time_lag_ms = 9;</code>
     */
    protected $read_time_lag_ms = 0;
    /**
     * Session identifier that locked and reading this partition right now.
     *
     * Generated from protobuf field <code>string session_id = 10;</code>
     */
    protected $session_id = '';
    /**
     * Ip if node that created reading this session.
     *
     * Generated from protobuf field <code>string client_node = 11;</code>
     */
    protected $client_node = '';
    /**
     * Host name of proxy node that processing this reading session.
     *
     * Generated from protobuf field <code>string proxy_node = 12;</code>
     */
    protected $proxy_node = '';
    /**
     * Host name of node where partition master is running.
     *
     * Generated from protobuf field <code>string tablet_node = 13;</code>
     */
    protected $tablet_node = '';
    /**
     * Assign identifier of actual partition assignment.
     *
     * Generated from protobuf field <code>uint64 assign_id = 14;</code>
     */
    protected $assign_id = 0;
    /**
     * Timestamp of assignment.
     *
     * Generated from protobuf field <code>uint64 assign_timestamp_ms = 15;</code>
     */
    protected $assign_timestamp_ms = 0;
    /**
     * Cookie of last performed read in session.
     *
     * Generated from protobuf field <code>uint64 last_read_cookie = 16;</code>
     */
    protected $last_read_cookie = 0;
    /**
     * Cookie upto whitch commits done.
     *
     * Generated from protobuf field <code>uint64 committed_read_cookie = 17;</code>
     */
    protected $committed_read_cookie = 0;
    /**
     * Cookie that client wants to commit, but server is waiting for committed_read_cookie + 1.
     *
     * Generated from protobuf field <code>repeated uint64 out_of_order_read_cookies_to_commit = 18;</code>
     */
    private $out_of_order_read_cookies_to_commit;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type int|string $partition
     *           Patition identifier inside topic.
     *     @type int $status
     *           Request status of partition.
     *     @type \Ydb\Issue\IssueMessage[]|\Google\Protobuf\Internal\RepeatedField $issues
     *           Issues if any.
     *     @type int|string $start_offset
     *           Offset of first message in partition.
     *     @type int|string $end_offset
     *           Offset of next not yet existing message in partition.
     *     @type int|string $commit_offset
     *           Offset of consumer committed message a.k.a. first not processed message.
     *           If commit_offset == end_offset then all messages from partition are processed.
     *     @type int|string $commit_time_lag_ms
     *           Consumer lag in time between committed and last messages in partition.
     *     @type int|string $read_offset
     *           Offset of first not read message by consumer from this partition.
     *           read_offset can be bigger that committed_offset - consumer could read some messages but not yet commit them.
     *     @type int|string $read_time_lag_ms
     *           Consumer lag in time between read and last messages in partition.
     *     @type string $session_id
     *           Session identifier that locked and reading this partition right now.
     *     @type string $client_node
     *           Ip if node that created reading this session.
     *     @type string $proxy_node
     *           Host name of proxy node that processing this reading session.
     *     @type string $tablet_node
     *           Host name of node where partition master is running.
     *     @type int|string $assign_id
     *           Assign identifier of actual partition assignment.
     *     @type int|string $assign_timestamp_ms
     *           Timestamp of assignment.
     *     @type int|string $last_read_cookie
     *           Cookie of last performed read in session.
     *     @type int|string $committed_read_cookie
     *           Cookie upto whitch commits done.
     *     @type int[]|string[]|\Google\Protobuf\Internal\RepeatedField $out_of_order_read_cookies_to_commit
     *           Cookie that client wants to commit, but server is waiting for committed_read_cookie + 1.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Kikimr\PBPublic\Api\Protos\YdbPersqueueV1::initOnce();
        parent::__construct($data);
    }

    /**
     * Patition identifier inside topic.
     *
     * Generated from protobuf field <code>uint64 partition = 1;</code>
     * @return int|string
     */
    public function getPartition()
    {
        return $this->partition;
    }

    /**
     * Patition identifier inside topic.
     *
     * Generated from protobuf field <code>uint64 partition = 1;</code>
     * @param int|string $var
     * @return $this
     */
    public function setPartition($var)
    {
        GPBUtil::checkUint64($var);
        $this->partition = $var;

        return $this;
    }

    /**
     * Request status of partition.
     *
     * Generated from protobuf field <code>.Ydb.StatusIds.StatusCode status = 2;</code>
     * @return int
     */
    public function getStatus()
    {
        return $this->status;
    }

    /**
     * Request status of partition.
     *
     * Generated from protobuf field <code>.Ydb.StatusIds.StatusCode status = 2;</code>
     * @param int $var
     * @return $this
     */
    public function setStatus($var)
    {
        GPBUtil::checkEnum($var, \Ydb\StatusIds\StatusCode::class);
        $this->status = $var;

        return $this;
    }

    /**
     * Issues if any.
     *
     * Generated from protobuf field <code>repeated .Ydb.Issue.IssueMessage issues = 3;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getIssues()
    {
        return $this->issues;
    }

    /**
     * Issues if any.
     *
     * Generated from protobuf field <code>repeated .Ydb.Issue.IssueMessage issues = 3;</code>
     * @param \Ydb\Issue\IssueMessage[]|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setIssues($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Ydb\Issue\IssueMessage::class);
        $this->issues = $arr;

        return $this;
    }

    /**
     * Offset of first message in partition.
     *
     * Generated from protobuf field <code>uint64 start_offset = 4;</code>
     * @return int|string
     */
    public function getStartOffset()
    {
        return $this->start_offset;
    }

    /**
     * Offset of first message in partition.
     *
     * Generated from protobuf field <code>uint64 start_offset = 4;</code>
     * @param int|string $var
     * @return $this
     */
    public function setStartOffset($var)
    {
        GPBUtil::checkUint64($var);
        $this->start_offset = $var;

        return $this;
    }

    /**
     * Offset of next not yet existing message in partition.
     *
     * Generated from protobuf field <code>uint64 end_offset = 5;</code>
     * @return int|string
     */
    public function getEndOffset()
    {
        return $this->end_offset;
    }

    /**
     * Offset of next not yet existing message in partition.
     *
     * Generated from protobuf field <code>uint64 end_offset = 5;</code>
     * @param int|string $var
     * @return $this
     */
    public function setEndOffset($var)
    {
        GPBUtil::checkUint64($var);
        $this->end_offset = $var;

        return $this;
    }

    /**
     * Offset of consumer committed message a.k.a. first not processed message.
     * If commit_offset == end_offset then all messages from partition are processed.
     *
     * Generated from protobuf field <code>uint64 commit_offset = 6;</code>
     * @return int|string
     */
    public function getCommitOffset()
    {
        return $this->commit_offset;
    }

    /**
     * Offset of consumer committed message a.k.a. first not processed message.
     * If commit_offset == end_offset then all messages from partition are processed.
     *
     * Generated from protobuf field <code>uint64 commit_offset = 6;</code>
     * @param int|string $var
     * @return $this
     */
    public function setCommitOffset($var)
    {
        GPBUtil::checkUint64($var);
        $this->commit_offset = $var;

        return $this;
    }

    /**
     * Consumer lag in time between committed and last messages in partition.
     *
     * Generated from protobuf field <code>uint64 commit_time_lag_ms = 7;</code>
     * @return int|string
     */
    public function getCommitTimeLagMs()
    {
        return $this->commit_time_lag_ms;
    }

    /**
     * Consumer lag in time between committed and last messages in partition.
     *
     * Generated from protobuf field <code>uint64 commit_time_lag_ms = 7;</code>
     * @param int|string $var
     * @return $this
     */
    public function setCommitTimeLagMs($var)
    {
        GPBUtil::checkUint64($var);
        $this->commit_time_lag_ms = $var;

        return $this;
    }

    /**
     * Offset of first not read message by consumer from this partition.
     * read_offset can be bigger that committed_offset - consumer could read some messages but not yet commit them.
     *
     * Generated from protobuf field <code>uint64 read_offset = 8;</code>
     * @return int|string
     */
    public function getReadOffset()
    {
        return $this->read_offset;
    }

    /**
     * Offset of first not read message by consumer from this partition.
     * read_offset can be bigger that committed_offset - consumer could read some messages but not yet commit them.
     *
     * Generated from protobuf field <code>uint64 read_offset = 8;</code>
     * @param int|string $var
     * @return $this
     */
    public function setReadOffset($var)
    {
        GPBUtil::checkUint64($var);
        $this->read_offset = $var;

        return $this;
    }

    /**
     * Consumer lag in time between read and last messages in partition.
     *
     * Generated from protobuf field <code>uint64 read_time_lag_ms = 9;</code>
     * @return int|string
     */
    public function getReadTimeLagMs()
    {
        return $this->read_time_lag_ms;
    }

    /**
     * Consumer lag in time between read and last messages in partition.
     *
     * Generated from protobuf field <code>uint64 read_time_lag_ms = 9;</code>
     * @param int|string $var
     * @return $this
     */
    public function setReadTimeLagMs($var)
    {
        GPBUtil::checkUint64($var);
        $this->read_time_lag_ms = $var;

        return $this;
    }

    /**
     * Session identifier that locked and reading this partition right now.
     *
     * Generated from protobuf field <code>string session_id = 10;</code>
     * @return string
     */
    public function getSessionId()
    {
        return $this->session_id;
    }

    /**
     * Session identifier that locked and reading this partition right now.
     *
     * Generated from protobuf field <code>string session_id = 10;</code>
     * @param string $var
     * @return $this
     */
    public function setSessionId($var)
    {
        GPBUtil::checkString($var, True);
        $this->session_id = $var;

        return $this;
    }

    /**
     * Ip if node that created reading this session.
     *
     * Generated from protobuf field <code>string client_node = 11;</code>
     * @return string
     */
    public function getClientNode()
    {
        return $this->client_node;
    }

    /**
     * Ip if node that created reading this session.
     *
     * Generated from protobuf field <code>string client_node = 11;</code>
     * @param string $var
     * @return $this
     */
    public function setClientNode($var)
    {
        GPBUtil::checkString($var, True);
        $this->client_node = $var;

        return $this;
    }

    /**
     * Host name of proxy node that processing this reading session.
     *
     * Generated from protobuf field <code>string proxy_node = 12;</code>
     * @return string
     */
    public function getProxyNode()
    {
        return $this->proxy_node;
    }

    /**
     * Host name of proxy node that processing this reading session.
     *
     * Generated from protobuf field <code>string proxy_node = 12;</code>
     * @param string $var
     * @return $this
     */
    public function setProxyNode($var)
    {
        GPBUtil::checkString($var, True);
        $this->proxy_node = $var;

        return $this;
    }

    /**
     * Host name of node where partition master is running.
     *
     * Generated from protobuf field <code>string tablet_node = 13;</code>
     * @return string
     */
    public function getTabletNode()
    {
        return $this->tablet_node;
    }

    /**
     * Host name of node where partition master is running.
     *
     * Generated from protobuf field <code>string tablet_node = 13;</code>
     * @param string $var
     * @return $this
     */
    public function setTabletNode($var)
    {
        GPBUtil::checkString($var, True);
        $this->tablet_node = $var;

        return $this;
    }

    /**
     * Assign identifier of actual partition assignment.
     *
     * Generated from protobuf field <code>uint64 assign_id = 14;</code>
     * @return int|string
     */
    public function getAssignId()
    {
        return $this->assign_id;
    }

    /**
     * Assign identifier of actual partition assignment.
     *
     * Generated from protobuf field <code>uint64 assign_id = 14;</code>
     * @param int|string $var
     * @return $this
     */
    public function setAssignId($var)
    {
        GPBUtil::checkUint64($var);
        $this->assign_id = $var;

        return $this;
    }

    /**
     * Timestamp of assignment.
     *
     * Generated from protobuf field <code>uint64 assign_timestamp_ms = 15;</code>
     * @return int|string
     */
    public function getAssignTimestampMs()
    {
        return $this->assign_timestamp_ms;
    }

    /**
     * Timestamp of assignment.
     *
     * Generated from protobuf field <code>uint64 assign_timestamp_ms = 15;</code>
     * @param int|string $var
     * @return $this
     */
    public function setAssignTimestampMs($var)
    {
        GPBUtil::checkUint64($var);
        $this->assign_timestamp_ms = $var;

        return $this;
    }

    /**
     * Cookie of last performed read in session.
     *
     * Generated from protobuf field <code>uint64 last_read_cookie = 16;</code>
     * @return int|string
     */
    public function getLastReadCookie()
    {
        return $this->last_read_cookie;
    }

    /**
     * Cookie of last performed read in session.
     *
     * Generated from protobuf field <code>uint64 last_read_cookie = 16;</code>
     * @param int|string $var
     * @return $this
     */
    public function setLastReadCookie($var)
    {
        GPBUtil::checkUint64($var);
        $this->last_read_cookie = $var;

        return $this;
    }

    /**
     * Cookie upto whitch commits done.
     *
     * Generated from protobuf field <code>uint64 committed_read_cookie = 17;</code>
     * @return int|string
     */
    public function getCommittedReadCookie()
    {
        return $this->committed_read_cookie;
    }

    /**
     * Cookie upto whitch commits done.
     *
     * Generated from protobuf field <code>uint64 committed_read_cookie = 17;</code>
     * @param int|string $var
     * @return $this
     */
    public function setCommittedReadCookie($var)
    {
        GPBUtil::checkUint64($var);
        $this->committed_read_cookie = $var;

        return $this;
    }

    /**
     * Cookie that client wants to commit, but server is waiting for committed_read_cookie + 1.
     *
     * Generated from protobuf field <code>repeated uint64 out_of_order_read_cookies_to_commit = 18;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getOutOfOrderReadCookiesToCommit()
    {
        return $this->out_of_order_read_cookies_to_commit;
    }

    /**
     * Cookie that client wants to commit, but server is waiting for committed_read_cookie + 1.
     *
     * Generated from protobuf field <code>repeated uint64 out_of_order_read_cookies_to_commit = 18;</code>
     * @param int[]|string[]|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setOutOfOrderReadCookiesToCommit($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::UINT64);
        $this->out_of_order_read_cookies_to_commit = $arr;

        return $this;
    }

}

// Adding a class alias for backwards compatibility with the previous class name.
class_alias(PartitionInfo::class, \Ydb\PersQueue\V1\ReadInfoResult_TopicInfo_PartitionInfo::class);

